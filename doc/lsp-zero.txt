==============================================================================
*lsp-zero.txt*

A starting point to setup some lsp related features in neovim.

==============================================================================
Introduction                                                  *lsp-zero-intro*

The purpose of this plugin is to bundle all the "boilerplate code" needed
to have |nvim-cmp| (a popular autocompletion plugin) and the |LSP| client
working together.

==============================================================================
Quickstart                                               *lsp-zero-quickstart*

The fastest way to get started is by using a "preset" and immediately call
the |lsp-zero.setup()| function.
>lua
  local lsp = require('lsp-zero').preset({})

  lsp.extend_cmp()

  lsp.on_attach(function(client, bufnr)
    lsp.default_keymaps({buffer = bufnr})
  end)

  -- Replace the language servers listed here
  -- with the ones you have installed
  lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
With this configuration lsp-zero will create keymaps to take advantage of some
features like jump to definition, rename variables, etc. It will also setup
the basic features of the autocompletion plugin.

=============================================================================
autocomplete                                          *lsp-zero-autocomplete*

The plugin responsable for autocompletion is |nvim-cmp|. This plugin is
designed to be unopinionated and modular. What this means for us (the users)
is that we have to assemble various pieces to get the behavior we want.

                                             *lsp-zero-completion-keybindings*

When you enable `set_basic_mappings` in the function |lsp-zero.extend_cmp()|
lsp-zero creates the following keybindings.

    <Ctrl-y>: ~
        Confirms selection.

    <Ctrl-e>: ~
        Cancel completion.

    <Up>: ~
        Navigate to previous item on the list.

    <Down>: ~
        Navigate to the next item on the list.

    <Ctrl-p>: ~
        If the completion menu is visible, go to the previous item.
        Else, trigger completion menu.

    <Ctrl-n>: ~
        If the completion menu is visible, go to the next item.
        Else, trigger completion menu.

    <Ctrl-u>: ~
        Scroll up in the item's documentation.

    <Ctrl-d>: ~
        Scroll down in the item's documentation.

And when you enable `set_extra_mappings` it creates these.

    <Ctrl-f>: ~
        Go to the next placeholder in the snippet.

    <Ctrl-b>: ~
        Go to the previous placeholder in the snippet.

    <Tab>: ~
        Enables completion when the cursor is inside a word. If the completion
        menu is visible it will navigate to the next item in the list.

    <Shift-Tab>: ~
        When the completion menu is visible navigate to the previous
        item in the list.

==============================================================================
LSP                                                      *lsp-zero-lsp-config*

Language servers are configured and initialized using |lspconfig|.

lsp-zero adds some extra "capabilities" to lspconfig's defaults, they tell the
language server what features |nvim-cmp| adds to the editor.

Then it creates an autocommand on the event |LspAttach|. This autocommand will
be triggered every time a language server is attached to a buffer. Is where
all keybindings and commands are created.

If you were to do it all by yourself, the code would look like this.
>lua
  local lspconfig = require('lspconfig')
  local lsp_defaults = lspconfig.util.default_config

  lsp_defaults.capabilities = vim.tbl_deep_extend(
    'force',
    lsp_defaults.capabilities,
    require('cmp_nvim_lsp').default_capabilities()
  )

  vim.api.nvim_create_autocmd('LspAttach', {
    desc = 'LSP actions',
    callback = function(event)
      vim.keymap.set('n', 'K', '<cmd>lua vim.lsp.buf.hover()<cr>', {buffer = true})
      -- More keybindings and commands....
    end
  })

  lspconfig.tsserver.setup({})
  lspconfig.rust_analyzer.setup({})
<
                                                           *lsp-zero-commands*

LspZeroFormat {server} timeout={timeout}: ~
    Formats the current buffer or range. Under the hood lsp-zero is using the
    function |vim.lsp.buf.format()|.

    If the "bang" is provided formatting will be asynchronous
    (ex: `LspZeroFormat!`).

    If you provide the name of a language server as a first argument it will
    try to format only using that server. Otherwise, it will use every
    active language server with formatting capabilities.

    With the {timeout} parameter you can configure the time in milliseconds
    to wait for the response of the formatting requests.

LspZeroWorkspaceRemove: ~
    Remove the folder at path from the workspace folders.
    See |vim.lsp.buf.remove_workspace_folder()|.

LspZeroWorkspaceAdd: ~
    Add the folder at path to the workspace folders.
    See |vim.lsp.buf.add_workspace_folder()|.

LspZeroWorkspaceList: ~
    List workspace folders. See |vim.lsp.buf.list_workspace_folders()|.

LspZeroSetupServers [{server}]: ~
    It takes a space separated list of servers and configures them.
    It calls the function |lsp-zero.setup_servers()| under the hood.
    If the `bang` is provided the root dir of the language server
    will be the same as neovim. Note that this command for when you
    decide to handle the configuration of servers manually, it will
    only do something when `setup_servers_on_start` is disabled.

                                                        *lsp-zero-keybindings*

When a language server gets attached to a buffer you gain access to some
keybindings and commands. All of these are bound to a built-in function
so you can get more details using the `:help` command.

K: ~
    Displays hover information about the symbol under the cursor in a
    floating window. See |vim.lsp.buf.hover()|.

gd: ~
    Jumps to the definition of the symbol under the cursor.
    See |vim.lsp.buf.definition()|.

gD: ~
    Jumps to the declaration of the symbol under the cursor. Some servers
    don't implement this feature. See |vim.lsp.buf.declaration()|.

gi: ~
    Lists all the implementations for the symbol under the cursor in the
    quickfix window. See |vim.lsp.buf.implementation()|.

go: ~
    Jumps to the definition of the type of the symbol under the cursor.
    See |vim.lsp.buf.type_definition()|.

gr: ~
    Lists all the references to the symbol under the cursor in the quickfix
    window. See |vim.lsp.buf.references()|.

gs: ~
    Displays signature information about the symbol under the cursor in a
    floating window. See |vim.lsp.buf.signature_help()|. If a mapping
    already exists for this key this function is not bound.

<F2>: ~
    Renames all references to the symbol under the cursor.
    See |vim.lsp.buf.rename()|.

<F3>: ~
    Format a buffer using the LSP servers attached to it.
    See |vim.lsp.buf.rename()|.

<F4>: ~
    Selects a code action available at the current cursor position.
    See |vim.lsp.buf.code_action()|.

gl: ~
    Show diagnostic in a floating window. See |vim.diagnostic.open_float()|.

[d: ~
    Move to the previous diagnostic in the current buffer.
    See |vim.diagnostic.goto_prev()|.

]d: ~
    Move to the next diagnostic. See |vim.diagnostic.goto_next()|.

==============================================================================
Lua API                                                     *lsp-zero-lua-api*

                                                           *lsp-zero.preset()*

preset({opts}): ~
    Here is where you can add settings specific to lsp-zero.

    The {opts} table supports the following properties.

        • float_border: (String, Optional) Defaults to `'rounded'`. Can have one
        of these: `'none'`, `'single'`, `'double'`, `'rounded'`, `'solid'` or
        `'shadow'`.

        • set_signcolumn: (Boolean, Optional) Defaults to `true`. When set to
        `true` it will reserve a space in the gutter for the diagnostic signs.

        • extend_lspconfig: (Boolean, Optional) Defaults to `true`. When set
        to `true` it will integrate nvim-cmp with lspconfig.
    
    Note that the return value is the same as the module `lsp-zero`, so this
    is valid (and encouraged).
>lua
    local lsp = require('lsp-zero').preset({
      float_border = 'rounded',
      set_signcolumn = true,
      extend_lspconfig = true,
    })
<
                                                        *lsp-zero.on_attach()*

on_attach({callback}): ~
    Execute {callback} function every time a server is attached
    to a buffer.

    This is the place where you can create your own keybindings.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      local noremap = {buffer = bufnr}
      local bind = vim.keymap.set

      bind('n', '<leader>r', '<cmd>lua vim.lsp.buf.rename()<cr>', noremap)
      -- more code  ...
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                  *lsp-zero.default_keymaps()*

default_keymaps({opts}): ~
    Create the keybindings bound to built-in LSP functions.

    The {opts} table supports the same properties as `set_lsp_keymaps` and
    adds the following:

        • buffer: (Number, Optional) Defaults to 0. The "id" of an open buffer.
        If the number 0 is provided then the keymaps will be effective in the
        current buffer.

        • preserve_mappings: (Boolean, Optional) Defaults to `true`. When set to
        `true` lsp-zero will not override your existing keybindings.

        • exclude: (Table, Optional) List of valid keybindings. lsp-zero will
        preserve the behavior of these keybindings.

    The best place to add this function is the callback of
    |lsp-zero.on_attach()|.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                *lsp-zero.set_server_config()*

set_server_config({opts}): ~
    Share a configuration for all LSP servers configured with |lspconfig|.
    You can find more details about {opts} see |lspconfig-setup|.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.set_server_config({
      single_file_support = false,
    })

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                        *lsp-zero.configure()*

configure({name}, {opts}): ~
    Useful when you need to pass some custom options to a specific
    language server. Takes the same options as `nvim-lspconfig`'s
    setup function. For more details go to |lspconfig-setup|.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.configure('tsserver', {
      single_file_support = false,
      on_attach = function(client, bufnr)
        print('hello tsserver')
      end
    })
<
                                                    *lsp-zero.setup_servers()*

setup_servers({list}): ~
    Will configure all the language servers you have on {list}.

    The {opts} table supports the following properties:

        • exclude: (Table, Optional). List of names of LSP servers you don't
        want to setup.

    Here is the basic usage.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                   *lsp-zero.default_setup()*

default_setup({server}): ~
    Configures {server} with the default config provided by lspconfig.

    This is meant to be used with |mason-lspconfig.nvim|, in order to help
    configure automatic setup of language servers. It can be added as a
    default handler in the setup function of the module `mason-lspconfig`.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('mason').setup({})
    require('mason-lspconfig').setup({
      handlers = {lsp.default_setup},
    })
<
                                                            *lsp-zero.noop()*

noop(): ~
    Doesn't do anything. Literally.

    You can use think of this as "empty handler" for |mason-lspconfig.nvim|.
    Consider this example.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('mason').setup({})
    require('mason-lspconfig').setup({
      ensure_installed = {'tsserver', 'eslint', 'jdtls'},
      handlers = {
        lsp.default_setup,
        jdtls = lsp.noop,
      },
    })
<
    In here `mason-lspconfig` will install all the servers in
    `ensure_installed`. Then it will try configure the servers but it will
    ignore `jdtls` because the handler doesn't do anything. So you are free to
    configure jdtls however you like.

                                                 *lsp-zero.get_capabilities()*

get_capabilities(): ~
    Returns Neovim's default capabilities mixed with the capabilities provided
    by the `cmp_nvim_lsp` plugin.

    This is useful when you want to configure a language using a specialized
    plugin. See the examples in quick-recipes.md:

    https://github.com/VonHeikemen/lsp-zero.nvim/blob/dev-v3/doc/md/guides/quick-recipes.md

                                                    *lsp-zero.build_options()*

build_options({server}, {opts}): ~
    Returns all the parameters necessary to start a language using
    lspconfig's setup function. After calling this function
    you'll need to initialize the language server by other means.

    The {opts} table will be merged with the rest of the default
    options for {server}.

                                                     *lsp-zero.store_config()*

store_config({name}, {opts}): ~
    Saves the configuration options for a language server, so you can
    use it at a later time in a local config file.

                                                              *lsp-zero.use()*

use({name}, {opts}): ~
    For when you want full control of the servers you want to use in a
    particular project. It is meant to be called in project local config.

    Ideally, you would setup some default values for your servers
    in your neovim config using |lsp-zero.configure()|.
>lua
    -- init.lua

    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.configure('pyright', {
      single_file_support = false,
    })
<
    And then in your local config you can tweak the server options even more.
>lua
    -- local config

    local lsp = require('lsp-zero')

    lsp.use('pyright', {
      settings = {
        python = {
          analysis = {
            extraPaths = {'/path/to/my/dependencies'},
          }
        }
      }
    })
<
    Options from |lsp-zero.store_config()| will be merged with the ones on
    |lsp-zero.use()| and the server will be initialized.

    Note: lsp-zero does not execute files. It only provides utility functions.
    So to execute your "local config" you'll have to use another plugin.

                                                      *lsp-zero.nvim_lua_ls()*

nvim_lua_ls({opts}): ~
    Returns settings specific to Neovim for the lua language server, lua_ls.
    If you provide the {opts} table it'll merge it with the defaults,
    this way you can extend or change the values easily.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').lua_ls.setup(lsp.nvim_lua_ls())
<
                                                   *lsp-zero.format_on_save()*
format_on_save({opts}): ~
    Setup autoformat on save. This will to allow you to associate a language
    server with a list of filetypes.

    Keep in mind it's only meant to allow one LSP server per filetype,
    this is so the formatting is consistent.

    {opts} supports the following properties:

        • servers: (Table) Key/value pair list. On the left hand side you must
        specify the name of a language server. On the right hand side you must
        provide a list of filetypes, this can be any pattern supported
        by the |FileType| autocommand.

        • format_opts: (Table, Optional). These are the same options you can pass to
        |vim.lsp.buf.format()|.

    When you enable async formatting the only arguments in `format_opts` that
    will have any effect are `formatting_options` and `timeout_ms`, the rest
    will be ignored.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.format_on_save({
      servers = {
        ['rust_analyzer'] = {'rust'},
        ['tsserver'] = {'javascript', 'typescript'},
      }
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                               *lsp-zero.buffer_autoformat()*

buffer_autoformat({client}, {bufnr}, {opts}): ~
    Format the current buffer using the active language servers.

    • {client}: (Table, Optional) if provided it must be a lua table with a
    `name` property or an instance of |vim.lsp.client|. If provided it will
    only use the LSP server associated with that client.

    • {bufnr}: (Number, Optional) if provided it must be the id
    of an open buffer.

    • {opts}: (Table). Additional options. It supports the following
    properties:

        • format_opts: (Table). These are the same options you can pass to
        |vim.lsp.buf.format()|.

>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
      lsp.buffer_autoformat()
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                               *lsp-zero.async_autoformat()*

async_autoformat({client}, {bufnr}, {opts}): ~
    Send a formatting request to {client}. After the getting the response
    from the client it will save the file (again).

    Here is how it works: when you save the file Neovim will write your
    changes without formatting. Then, lsp-zero will send a request to
    {client}, when it gets the response it will apply the formatting and
    save the file again.

    • {client}: (Table) It must be an instance of |vim.lsp.client|.

    • {bufnr}: (Number, Optional) if provided it must be the id of an open
    buffer.

    • {opts}: (Table, Optional). Supports the following properties:

        • formatting_options: Settings send to the language server. These
        are the same settings as the `formatting_options` argument in
        |vim.lsp.buf.format()|.

        • timeout_ms: (Number, Optional) Defaults to 10000. Time in
        milliseconds to ignore the current format request.

    Do not use this in the global `on_attach`, call this function
    with the specific language server you want to format with.

    Here is an example.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').tsserver.setup({
      on_attach = function(client, bufnr)
        lsp.async_autoformat(client, bufnr)
      end
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'rust_analyzer'})
<
                                                   *lsp-zero.format_mapping()*
format_mapping({key}, {opts}): ~
    Configure {key} to format the current buffer.

    The idea here is that you associate a language server with a list of
    filetypes, so {key} can format the buffer using only one LSP server.

    {opts} supports the following properties:

        • servers: (Table) Key/value pair list. On the left hand side you must
        specify the name of a language server. On the right hand side you must
        provide a list of filetypes, this can be any pattern supported
        by the |FileType| autocommand.

        • format_opts: (Table). These are the same options you can pass to
        |vim.lsp.buf.format()|.

        • mode: (Table). The list of modes where the keybinding will be active.
        By default is set to `{'n', 'x'}`, which means normal mode and visual
        mode.

>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.format_mapping('gq', {
      servers = {
        ['rust_analyzer'] = {'rust'},
        ['tsserver'] = {'javascript', 'typescript'},
      }
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                   *lsp-zero.set_sign_icons()*

set_sign_icons({opts}): ~
    Defines the sign icons that appear in the gutter.

    {opts} table supports these properties:

        • error: (String, Optional) Text for the error signs.

        • warn: (String, Optional) Text for the warning signs.

        • hint: (String, Optional) Text for the hint signs.

        • info: (String, Optional) Text for the information signs.

    Here is an example with basic icons (doesn't require a nerd fonts).
>lua
    local lsp = require('lsp-zero')

    lsp.set_sign_icons({
      error = '✘',
      warn = '▲',
      hint = '⚑',
      info = '»'
    })
<
                                                       *lsp-zero.new_server()*

new_server({opts}): ~
    lsp-zero will execute a user provided function to detect the root
    directory of the project when Neovim assigns the file type for a
    buffer. If the root directory is detected the LSP server will be
    attached to the file.

    This function does not depend on `lspconfig`, it's a thin wrapper
    around a Neovim function called |vim.lsp.start()|.

    {opts} supports every property |vim.lsp.start()| supports with
    a few changes:

        • filestypes: (Table) Can be list filetype names. This can be
        any pattern the `FileType` autocommand accepts.

        • root_dir: Can be a function, it'll be executed after Neovim
        assigns the file type for a buffer. If it returns a string
        that will be considered the root directory for the project.

    Other important properties are:

        • cmd: (Table) A lua table with the arguments necessary to start
        the language server.

        • name: (String) The name Neovim will assign to the client object.

        • on_attach: (Function) A function that will be executed after
        the language server gets attached to a buffer.

    Here is an example that starts the typescript language server on
    javascript and typescript, but only in a project that package.json
    in the current directory or any of its parent folders.
>lua
    local lsp = require('lsp-zero')

    lsp.extend_cmp()

    lsp.on_attach(function()
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.new_server({
      name = 'tsserver',
      cmd = {'typescript-language-server', '--stdio'},
      filetypes = {'javascript', 'typescript'},
      root_dir = function()
        return lsp.dir.find_first({'package.json'})
      end
    })
<
                                                   *lsp-zero.dir.find_first()*

dir.find_first({list}): ~
    Checks the parent directories and returns the path to the first folder
    that has a file in {list}. Useful to detect the root directory.

    {list} supports the following properties:

      • path: (String, Optional) The path from where it should start looking for
      the files in {list}.

      • buffer: (Boolean, Optional) When enabled it will use the path of the
      current buffer.

    Note: search will stop once it gets to your "HOME" folder.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').lua_ls.setup({
      root_dir = function()
        --- project root will be the first directory that has
        --- either .luarc.json or .stylua.toml
        return lsp.dir.find_first({'.luarc.json', '.stylua.toml'})
      end
    })
<
                                                     *lsp-zero.dir.find_all()*

dir.find_all({list}): ~
    Checks the parent directories and returns the path to the first folder
    that has all the files in {list}. Useful to detect the root directory.

    {list} supports the following properties:

      • path: (String, Optional) The path from where it should start looking
      for the files in {list}.

      • buffer: (Boolean, Optional) When enabled use the path of the current
      buffer.

    Note: search will stop once it gets to your "HOME" folder.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').lua_ls.setup({
      root_dir = function()
        --- project root will be the first directory that has
        --- either .luarc.json or .stylua.toml
        return lsp.dir.find_first({'.luarc.json', '.stylua.toml'})
      end
    })
<

                                                 *lsp-zero.extend_lspconfig()*

extend_lspconfig(): ~
    Takes care of the integration between lspconfig and nvim-cmp.

    It extends the `capabilities` option in lspconfig's defaults, using the
    plugin `cmp_nvim_lsp`. And it creates a "hook" so users can provide their
    own default config using |lsp-zero.set_server_config()|.

                                                       *lsp-zero.cmp_action()*

cmp_action(): ~
    Returns methods meant to be used as mappings for |nvim-cmp|.

    These are the supported methods:

        • tab_complete: ~
            Enables completion when the cursor is inside a word. If the
            completion menu is visible it will navigate to the next item in
            the list. If the line is empty it uses the fallback.

        • select_prev_or_fallback: ~
            If the completion menu is visible navigate to the
            previous item in the list. Else, uses the fallback.

        • toggle_completion: ~
            If the completion menu is visible it cancels the process.
            Else, it triggers the completion menu.

        • luasnip_jump_forward: ~
            Go to the next placeholder in the snippet.

        • luasnip_jump_backward: ~
            Go to the previous placeholder in the snippet.

        • luasnip_next: ~
            If completion menu is visible it will navigate to the item in the
            list. If the cursor can jump to a snippet placeholder, it moves to
            it. Else, it uses the fallback.

        • luasnip_next_or_expand: ~
            If completion menu is visible it will navigate to the item in the
            list. If cursor is on top of the trigger of a snippet it'll expand
            it. If the cursor can jump to a snippet placeholder, it moves to
            it. Else, it uses the fallback.

        • luasnip_supertab: ~
            If the completion menu is visible it will navigate to the
            next item in the list. If cursor is on top of the trigger
            of a snippet it'll expand it. If the cursor can jump to a
            snippet placeholder, it moves to it. If the cursor is in
            the middle of a word that doesn't trigger a snippet it
            displays the completion menu. Else, it uses the fallback.

        • luasnip_shift_supertab: ~
            If the completion menu is visible it'll navigate to previous item
            in the list. If the cursor can navigate to a previous snippet
            placeholder, it moves to it. Else, it uses the fallback.

    Quick note: "the fallback" is the default behavior of the key
    you assign to a method.

                                                       *lsp-zero.extend_cmp()*

extend_cmp({opts}): ~
    Creates a minimal working config for nvim-cmp.

    {opts} supports the following properties:

        • set_lsp_source: (Boolean, Optional) Defaults to `true`. When enabled
        it adds `cmp-nvim-lsp` as a source.

        • set_basic_mappings: (Boolean, Optional) Defaults to `true`. When
        enabled it will create keybindings that emulate Neovim's default
        completions bindings.

        • set_extra_mappings: (Boolean, Optional) Defaults to `false`. When
        enabled it will setup tab completion, scrolling through documentation
        window, and navigation between snippets.

        • use_luasnip: (Boolean, Optional) Defaults to `true`. When enabled it
        will setup luasnip to expand snippets. This option does not include a
        collection of snippets.

        • set_format: (Boolean, Optional) Defaults to `true`. When enabled it
        will the completion items will show a label that identifies the source
        they come from. 

        • documentation_window: (Boolean, Optional) Defaults to `true`. When
        enabled it will configure the max height and width of the
        documentation window.

    After you use this function you can customize nvim-cmp using the module
    `cmp`. Here is an example that adds some keybindings.
>lua
    require('lsp-zero').extend_cmp()

    local cmp = require('cmp')
    local cmp_action = require('lsp-zero').cmp_action()

    cmp.setup({
      mapping = {
        ['<C-Space>'] = cmp.mapping.complete(),
        ['<C-f>'] = cmp_action.luasnip_jump_forward(),
        ['<C-b>'] = cmp_action.luasnip_jump_backward(),
      }
    })
<
                                                   *lsp-zero.omnifunc.setup()*

.omnifunc.setup({opts}): ~
    Configure the behavior of Neovim's completion mechanism. If for some
    reason you refuse to install nvim-cmp you can use this function to
    make the built-in completions more user friendly.

    {opts} supports the following properties:

        • autocomplete: (String, Optional) Defaults to `false`. When enabled
        it triggers the completion menu if the character under the cursor
        matches `opts.keyword_pattern`. Completions will be disabled when you
        are recording a macro. Do note, the implementation here is extremely
        simple, there isn't any kind of optimizations in place. Is literally
        like pressing `<Ctrl-x><Ctrl-o>` after you insert a character in a
        word.

        • tabcomplete: (Boolean, Optional) Defaults to `false`. When enabled
        `<Tab>` will trigger the completion menu if the cursor is in the
        middle of a word. When the completion menu is visible it will navigate
        to the next item in the menu. If there is a blank character under the
        cursor it inserts a `Tab` character. `<Shift-Tab>` will navigate to
        the previous item in the menu, and if the menu is not visible it'll
        insert a `Tab` character.

        • trigger: (String, Optional) It must be a valid keyboard shortcut.
        This will be used as a keybinding to trigger the completion menu
        manually. Actually, it will be able to toggle the completion menu.
        You'll be able to show and hide the menu with the same keybinding.

        • use_fallback: (Boolean, Optional) Defaults to `false`. When enabled
        lsp-zero will try to complete using the words in the current buffer.
        And when an LSP server is attached to the buffer, it will replace the
        fallback completion with the LSP completions.

        • keyword_pattern: (String, Optional) Defaults to `"[[:keyword:]]"`.
        Regex pattern used by the autocomplete implementation.

        • update_on_delete: (Boolean, Optional) Defaults to `false`. Turns out
        Neovim will hide the completion menu when you delete a character, so
        when you enable this option lsp-zero will trigger the menu again after
        you press `<backspace>`. This will only happen with LSP completions,
        the fallback completion updates automatically (again, this is Neovim's
        default behavior). This option is disabled by default because it
        requires lsp-zero to bind the backspace key, which may cause conflicts
        with other plugins.

        • select_behavior: (String, Optional) Defaults to `"select"`.
        Configures what happens when you select an item in the completion
        menu. When the value is `"insert"` Neovim will insert the text of the
        item in the buffer. When the value is `"select"` nothing happens,
        Neovim will only highlight the item in the menu, the text in the
        buffer will not change.

        • preselect: (Boolean, Optional) Defaults to `true`. When enabled the
        first item in the completion menu will be selected automatically.

        • verbose: (Boolean, Optional) Defaults to `false`. When enabled
        Neovim will show the state of the completion in message area.

        • mapping: (Table, Optional) Defaults to an empty table. With this you
        can configure the keybinding for common actions.

            • confirm: Accept the selected completion item.

            • abort: Cancel current completion.

            • next_item: Navigate to next item in the completion menu.

            • prev_item: Navigate to previous item in the completion menu.

    You can configure a basic "tab completion" behavior using these settings.
>lua
    local lsp = require('lsp-zero')

    lsp.omnifunc.setup({
      tabcomplete = true,
      use_fallback = true,
      update_on_delete = true,
    })
<
    And here is an example for autocomplete.
>lua
    local lsp = require('lsp-zero')

    lsp.omnifunc.setup({
      autocomplete = true,
      use_fallback = true,
      update_on_delete = true,
      trigger = '<C-Space>',
    })
<
==============================================================================
Guides                                                       *lsp-zero-guides*

                                   *lsp-zero-guide:integrate-with-mason-nvim*

Integrate with mason.nvim

We can use |mason.nvim| and |mason-lspconfig.nvim| to help us manage the
installation of language servers. And then we can use lsp-zero to help with
the automatic configuration.

Here is a basic example.
>lua
  local lsp = require('lsp-zero').preset({})

  lsp.on_attach(function(client, bufnr)
    lsp.default_keymaps({buffer = bufnr})
  end)

  lsp.extend_cmp()

  require('mason').setup({})
  require('mason-lspconfig').setup({
    -- Replace the language servers listed here 
    -- with the ones you want to install
    ensure_installed = {'tsserver', 'rust_analyzer'},
    handlers = {lsp.default_setup},
  })
<

This config will tell `mason-lspconfig` to install tsserver and rust_analyzer
automatically if they are missing. And lsp-zero will handle the configuration
of those servers.

Note that after you install a language server you will need to restart Neovim
so the language can be configured properly.

If we need to add a custom configuration for a server, you'll need to add a
property to `handlers`. This new property must have the same name as the
language server you want to configure, and you need to assign a function to
it.

Lets use `tsserver` as an example.
>lua
  require('mason-lspconfig').setup({
    ensure_installed = {'tsserver', 'rust_analyzer'},
    handlers = {
      lsp.default_setup,
      tsserver = function()
        require('lspconfig').tsserver.setup({
          settings = {
            completions = {
              completeFunctionCalls = true
            }
          }
        })
      end,
    },
  })
<
Here we use the module `lspconfig` to setup the language server and we add our
custom config in the first argument of `.tsserver.setup()`.

On the other hand if we want to ignore a language server we can use the
function |lsp-zero.noop()|.
>lua
  require('mason-lspconfig').setup({
    ensure_installed = {'tsserver', 'rust_analyzer'},
    handlers = {
      lsp.default_setup,
      tsserver = lsp.noop,
    },
  })
<
This will cause `mason-lspconfig` to exclude `tsserver` from the automatic
setup.

                                          *lsp-zero-guide:lua-lsp-for-neovim*

Configure lua language server for Neovim

There are two ways you can do this:

• Project specific config

We can create a file called .luarc.json file in Neovim's config folder and the
following config.
>
  {
    "runtime.version": "LuaJIT",
    "runtime.path": [
      "lua/?.lua",
      "lua/?/init.lua"
    ],
    "diagnostics.globals": ["vim"],
    "workspace.checkThirdParty": false,
    "workspace.library": [
      "/usr/share/nvim/runtime/lua",
      "./lua"
    ]
  }
<
The first path in the `workspace.library` property is the path to Neovim's
runtime files. This might be different for you, so make sure to check using
this command `:echo $VIMRUNTIME`

• Fixed config

If your Neovim config is the only lua project you have in your system, use the
function |lsp-zero.nvim_lua_ls()| to get the config and then setup `lua_ls`
with lspconfig.
>lua
  local lsp = require('lsp-zero').preset({})

  lsp.on_attach(function(client, bufnr)
    lsp.default_keymaps({buffer = bufnr})
  end)

  lsp.extend_cmp()

  require('lspconfig').lua_ls.setup(lsp.nvim_lua_ls())
<
If you used |mason-lspconfig.nvim| to setup your language servers, add
`lua_ls` to your handlers config.
>lua
  require('mason-lspconfig').setup({
    handlers = {
      lsp.default_setup,
      lua_ls = function()
        require('lspconfig').lua_ls.setup(lsp.nvim_lua_ls())
      end,
    },
  })
<
                                          *lsp-zero-guide:customize-nvim-cmp*

Customize nvim-cmp

To setup a basic working config for nvim-cmp you can use the function
|lsp-zero.extend_cmp()|. And after that you can call the setup function of the
`cmp` module. Here is a quick example.
>lua
  require('lsp-zero').extend_cmp()

  local cmp = require('cmp')
  local cmp_action = require('lsp-zero').cmp_action()

  cmp.setup({
    window = {
      completion = cmp.config.window.bordered(),
      documentation = cmp.config.window.bordered(),
    },
    mapping = {
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-f>'] = cmp_action.luasnip_jump_forward(),
      ['<C-b>'] = cmp_action.luasnip_jump_backward(),
    }
  })
<
When configuring the `sources` option make sure to add the source for the LSP
completions.
>lua
  require('lsp-zero').extend_cmp()

  local cmp = require('cmp')

  cmp.setup({
    sources = {
      {name = 'nvim_lsp'},
    }
  })
<

Always include `{name = 'nvim_lsp'}` in your sources.

==============================================================================
Version                                                     *lsp-zero-version*

Current version: `v3-dev`

This is a development branch, breaking changes can happen. 

The code on this version requires Neovim v0.8 or greater. If you need support
for Neovim v0.7 or lower use the `v1.x` branch of lsp.zero.

==============================================================================
Support                                                    *lsp-zero-donation*

If you find this tool useful and want to support my efforts, consider
leaving a tip in https://www.buymeacoffee.com/vonheikemen

vim:tw=78:ft=help:norl:
