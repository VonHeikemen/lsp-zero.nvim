==============================================================================
*lsp-zero.txt*

A starting point to setup some LSP related features in Neovim.

==============================================================================
Introduction                                                  *lsp-zero-intro*

The purpose of this plugin is to bundle all the "boilerplate code" needed
to have |nvim-cmp| (a popular autocompletion plugin) and the |LSP| client
working together.

==============================================================================
Quickstart                                               *lsp-zero-quickstart*

You can use lsp-zero to create keymaps that will allow you to access features
like jump to definition, rename variables, etc. It also can help you setup
the basic features of the autocompletion plugin.

Here is a basic configuration to get started.
>lua
  local lsp_zero = require('lsp-zero')

  lsp_zero.on_attach(function(client, bufnr)
    -- see :help lsp-zero-keybindings
    -- to learn the available actions
    lsp_zero.default_keymaps({buffer = bufnr})
  end)

  -- Replace the language servers listed here
  -- with the ones you have installed
  lsp_zero.setup_servers({'tsserver', 'rust_analyzer'})
<
Note that you will need to install a language server for this to work. You can
access the list of supported language servers using this command:

:help lspconfig-all

=============================================================================
autocomplete                                          *lsp-zero-autocomplete*

The plugin responsable for autocompletion is |nvim-cmp|. This plugin is
designed to be unopinionated and modular. What this means for us (the users)
is that we have to assemble various pieces to get the behavior we want.

                                             *lsp-zero-completion-keybindings*

This are the keybindings lsp-zero enables by default.

    <Ctrl-y>: ~
        Confirms selection.

    <Ctrl-e>: ~
        Cancel completion.

    <Up>: ~
        Navigate to previous item on the list.

    <Down>: ~
        Navigate to the next item on the list.

    <Ctrl-p>: ~
        If the completion menu is visible, go to the previous item.
        Else, trigger completion menu.

    <Ctrl-n>: ~
        If the completion menu is visible, go to the next item.
        Else, trigger completion menu.

==============================================================================
LSP                                                      *lsp-zero-lsp-config*

Language servers are configured and initialized using |lspconfig|.

lsp-zero adds some extra "capabilities" to lspconfig's defaults, they tell the
language server what features |nvim-cmp| adds to the editor.

Then it creates an autocommand on the event |LspAttach|. This autocommand will
be triggered every time a language server is attached to a buffer. Is where
all keybindings and commands are created.

If you were to do it all by yourself, the code would look like this.
>lua
  local lspconfig = require('lspconfig')
  local lsp_defaults = lspconfig.util.default_config

  lsp_defaults.capabilities = vim.tbl_deep_extend(
    'force',
    lsp_defaults.capabilities,
    require('cmp_nvim_lsp').default_capabilities()
  )

  vim.api.nvim_create_autocmd('LspAttach', {
    desc = 'LSP actions',
    callback = function(event)
      vim.keymap.set('n', 'K', '<cmd>lua vim.lsp.buf.hover()<cr>', {buffer = event.buf})
      -- More keybindings and commands....
    end
  })

  lspconfig.tsserver.setup({})
  lspconfig.rust_analyzer.setup({})
<
                                                           *lsp-zero-commands*

LspZeroFormat {server} timeout={timeout}: ~
    Formats the current buffer or range. Under the hood lsp-zero is using the
    function |vim.lsp.buf.format()|.

    If the "bang" is provided formatting will be asynchronous
    (ex: `LspZeroFormat!`).

    If you provide the name of a language server as a first argument it will
    try to format only using that server. Otherwise, it will use every
    active language server with formatting capabilities.

    With the {timeout} parameter you can configure the time in milliseconds
    to wait for the response of the formatting requests.

LspZeroWorkspaceRemove: ~
    Remove the folder at path from the workspace folders.
    See |vim.lsp.buf.remove_workspace_folder()|.

LspZeroWorkspaceAdd: ~
    Add the folder at path to the workspace folders.
    See |vim.lsp.buf.add_workspace_folder()|.

LspZeroWorkspaceList: ~
    List workspace folders. See |vim.lsp.buf.list_workspace_folders()|.

LspZeroSetupServers [{server}]: ~
    It takes a space separated list of servers and configures them.
    It calls the function |lsp-zero.setup_servers()| under the hood.
    If the `bang` is provided the root dir of the language server
    will be the same as neovim. Note that this command for when you
    decide to handle the configuration of servers manually, it will
    only do something when `setup_servers_on_start` is disabled.

                                                        *lsp-zero-keybindings*

If you choose to use the function |lsp-zero.default_keymaps()|, you gain
access to some keybindings. All of these are bound to a built-in
function so you can get more details using the `:help` command.

K: ~
    Displays hover information about the symbol under the cursor in a
    floating window. See |vim.lsp.buf.hover()|.

gd: ~
    Jumps to the definition of the symbol under the cursor.
    See |vim.lsp.buf.definition()|.

gD: ~
    Jumps to the declaration of the symbol under the cursor. Some servers
    don't implement this feature. See |vim.lsp.buf.declaration()|.

gi: ~
    Lists all the implementations for the symbol under the cursor in the
    quickfix window. See |vim.lsp.buf.implementation()|.

go: ~
    Jumps to the definition of the type of the symbol under the cursor.
    See |vim.lsp.buf.type_definition()|.

gr: ~
    Lists all the references to the symbol under the cursor in the quickfix
    window. See |vim.lsp.buf.references()|.

gs: ~
    Displays signature information about the symbol under the cursor in a
    floating window. See |vim.lsp.buf.signature_help()|. If a mapping
    already exists for this key this function is not bound.

<F2>: ~
    Renames all references to the symbol under the cursor.
    See |vim.lsp.buf.rename()|.

<F3>: ~
    Format a buffer using the LSP servers attached to it.
    See |vim.lsp.buf.format()|.

<F4>: ~
    Selects a code action available at the current cursor position.
    See |vim.lsp.buf.code_action()|.

gl: ~
    Show diagnostic in a floating window. See |vim.diagnostic.open_float()|.

[d: ~
    Move to the previous diagnostic in the current buffer.
    See |vim.diagnostic.goto_prev()|.

]d: ~
    Move to the next diagnostic. See |vim.diagnostic.goto_next()|.

==============================================================================
Global variables                                   *lsp-zero-global-variables*

lsp_zero_extend_cmp: ~
    When set to `0` then lsp-zero will not integrate with nvim-cmp
    automatically.

lsp_zero_extend_lspconfig: ~
    When set to `0` then lsp-zero will not integrate with lspconfig
    automatically.

lsp_zero_ui_float_border: ~
    Set the style of border of diagnostic floating window, hover window and
    signature help window. Can have one of these: `'none'`, `'single'`,
    `'double'`, `'rounded'`, `'solid'` or `'shadow'`. The default value is
    `'rounded'`. If set to `0` then lsp-zero will not configure the border
    style.

lsp_zero_ui_signcolumn: ~
    When set to `0` the lsp-zero will not configure the space in the gutter
    for diagnostics.

lsp_zero_api_warnings: ~
    When set to `0` it will supress the warning messages from deprecated
    functions. (Note: if you get one of those warnings, know that showing that
    message is the only thing they do. They are "empty" functions.)

Now, when I say global variable I mean a vim global variable. So to modify
them from lua you would do something like this
>lua
  vim.g.lsp_zero_extend_lspconfig = 0
<
But if you are using vimscript, you can do something like this
>vim
  let g:lsp_zero_extend_lspconfig = 0
<
==============================================================================
Lua API                                                     *lsp-zero-lua-api*

                                                        *lsp-zero.on_attach()*

on_attach({callback}): ~
    Execute {callback} function every time a server is attached
    to a buffer.

    This is the place where you can create your own keybindings.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      local opts = {buffer = bufnr}

      vim.keymap.set('n', '<leader>r', '<cmd>lua vim.lsp.buf.rename()<cr>', opts)
      -- more code  ...
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp_zero.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                  *lsp-zero.default_keymaps()*

default_keymaps({opts}): ~
    Create the keybindings bound to built-in LSP functions.

    The {opts} table supports the same properties as `set_lsp_keymaps` and
    adds the following:

        • buffer: (Number, Optional) Defaults to 0. The "id" of an open buffer.
        If the number 0 is provided then the keymaps will be effective in the
        current buffer.

        • preserve_mappings: (Boolean, Optional) Defaults to `true`. When set to
        `true` lsp-zero will not override your existing keybindings.

        • exclude: (Table, Optional) List of valid keybindings. lsp-zero will
        preserve the behavior of these keybindings.

    The best place to add this function is the callback of
    |lsp-zero.on_attach()|.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      -- see :help lsp-zero-keybindings
      -- to learn the available actions
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp_zero.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                *lsp-zero.set_server_config()*

set_server_config({opts}): ~
    Share a configuration for all LSP servers configured with |lspconfig|.
    You can find more details about {opts} see |lspconfig-setup|.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.set_server_config({
      single_file_support = false,
    })

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp_zero.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                        *lsp-zero.configure()*

configure({name}, {opts}): ~
    Useful when you need to pass some custom options to a specific
    language server. Takes the same options as `nvim-lspconfig`'s
    setup function. For more details go to |lspconfig-setup|.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    lsp_zero.configure('tsserver', {
      single_file_support = false,
      on_attach = function(client, bufnr)
        print('hello tsserver')
      end
    })
<
                                                    *lsp-zero.setup_servers()*

setup_servers({list}): ~
    Will configure all the language servers you have on {list}.

    The {opts} table supports the following properties:

        • exclude: (Table, Optional). List of names of LSP servers you don't
        want to setup.

    Here is the basic usage.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp_zero.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                   *lsp-zero.default_setup()*

default_setup({server}): ~
    Configures {server} with the default config provided by lspconfig.

    This is meant to be used with |mason-lspconfig.nvim|, in order to help
    configure automatic setup of language servers. It can be added as a
    default handler in the setup function of the module `mason-lspconfig`.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    require('mason').setup({})
    require('mason-lspconfig').setup({
      handlers = {
        lsp_zero.default_setup,
      },
    })
<
                                                            *lsp-zero.noop()*

noop(): ~
    Doesn't do anything. Literally.

    You can use think of this as "empty handler" for |mason-lspconfig.nvim|.
    Consider this example.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    require('mason').setup({})
    require('mason-lspconfig').setup({
      ensure_installed = {'tsserver', 'eslint', 'jdtls'},
      handlers = {
        lsp_zero.default_setup,
        jdtls = lsp_zero.noop,
      },
    })
<
    In here `mason-lspconfig` will install all the servers in
    `ensure_installed`. Then it will try configure the servers but it will
    ignore `jdtls` because the handler doesn't do anything. So you are free to
    configure jdtls however you like.

                                                 *lsp-zero.get_capabilities()*

get_capabilities(): ~
    Returns Neovim's default capabilities mixed with the capabilities provided
    by the `cmp_nvim_lsp` plugin.

    This is useful when you want to configure a language using a specialized
    plugin. See the examples in quick-recipes.md:

    https://github.com/VonHeikemen/lsp-zero.nvim/blob/v3.x/doc/md/guides/quick-recipes.md

                                                    *lsp-zero.build_options()*

build_options({server}, {opts}): ~
    Returns all the parameters necessary to start a language using
    lspconfig's setup function. After calling this function
    you'll need to initialize the language server by other means.

    The {opts} table will be merged with the rest of the default
    options for {server}.

                                                     *lsp-zero.store_config()*

store_config({name}, {opts}): ~
    Saves the configuration options for a language server, so you can
    use it at a later time in a local config file.

                                                              *lsp-zero.use()*

use({name}, {opts}): ~
    For when you want full control of the servers you want to use in a
    particular project. It is meant to be called in project local config.

    Ideally, you would setup some default values for your servers
    in your neovim config using |lsp-zero.configure()|.
>lua
    -- init.lua

    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    lsp_zero.configure('pyright', {
      single_file_support = false,
    })
<
    And then in your local config you can tweak the server options even more.
>lua
    -- local config

    local lsp_zero = require('lsp-zero')

    lsp_zero.use('pyright', {
      settings = {
        python = {
          analysis = {
            extraPaths = {'/path/to/my/dependencies'},
          }
        }
      }
    })
<
    Options from |lsp-zero.store_config()| will be merged with the ones on
    |lsp-zero.use()| and the server will be initialized.

    Note: lsp-zero does not execute files. It only provides utility functions.
    So to execute your "local config" you'll have to use another plugin.

                                                      *lsp-zero.nvim_lua_ls()*

nvim_lua_ls({opts}): ~
    Returns settings specific to Neovim for the lua language server, lua_ls.
    If you provide the {opts} table it'll merge it with the defaults,
    this way you can extend or change the values easily.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    local lua_opts = lsp_zero.nvim_lua_ls()
    require('lspconfig').lua_ls.setup(lua_opts)
<
                                                   *lsp-zero.format_on_save()*
format_on_save({opts}): ~
    Setup autoformat on save. This will to allow you to associate a language
    server with a list of filetypes.

    This function was designed to allow one LSP server per filetype, this is
    so the formatting is consistent.

    {opts} supports the following properties:

        • servers: (Table) Key/value pair list. On the left hand side you must
        specify the name of a language server. On the right hand side you must
        provide a list of filetypes, this can be any pattern supported
        by the |FileType| autocommand.

        • format_opts: (Table, optional). Configuration that will passed to
        the formatting function. It supports the following properties:

            • async: (Boolean, optional). If true it will send an
              asynchronous format request to the LSP server.

            • timeout_ms: (Number, optional). Time in milliseconds to block
            for formatting requests. Defaults to `10000`.

            • formatting_options: (Table, optional). Can be used to set
            `FormattingOptions`, these options are sent to the language
            server. See https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#formattingOptions

    When you enable format on save your LSP server is doing the formatting.
    The LSP server does not share the same style configuration as Neovim. Tabs
    and indents can change after the LSP formats the code in the file. Read
    the documentation of the LSP server you are using, figure out how to
    configure it to your prefered style.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    lsp_zero.format_on_save({
      format_opts = {
        async = false,
        timeout_ms = 10000,
      },
      servers = {
        ['rust_analyzer'] = {'rust'},
        ['tsserver'] = {'javascript', 'typescript'},
      }
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp_zero.setup_servers({'tsserver', 'rust_analyzer'})
<
                                               *lsp-zero.buffer_autoformat()*

buffer_autoformat({client}, {bufnr}, {opts}): ~
    Format the current buffer using the active language servers.

    • {client}: (Table, Optional) if provided it must be a lua table with a
    `name` property or an instance of |vim.lsp.client|. If provided it will
    only use the LSP server associated with that client.

    • {bufnr}: (Number, Optional) if provided it must be the id
    of an open buffer.

    • {opts}: (Table, optional). Configuration that will passed to
    the formatting function. It supports the following properties:

        • timeout_ms: (Number, optional). Time in milliseconds to block
        for formatting requests. Defaults to `10000`.

        • formatting_options: (Table, optional). Can be used to set
        `FormattingOptions`, these options are sent to the language
        server. See https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#formattingOptions

    Tabs and indents can change after the LSP formats the code in the file. Read
    the documentation of the LSP servers you are using, figure out how to
    configure it to your prefered style.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
      lsp_zero.buffer_autoformat()
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp_zero.setup_servers({'tsserver', 'rust_analyzer'})
<
                                               *lsp-zero.async_autoformat()*

async_autoformat({client}, {bufnr}, {opts}): ~
    Send a formatting request to {client}. After the getting the response
    from the client it will save the file (again).

    Here is how it works: when you save the file Neovim will write your
    changes without formatting. Then, lsp-zero will send a request to
    {client}, when it gets the response it will apply the formatting and
    save the file again.

    • {client}: (Table) It must be an instance of |vim.lsp.client|.

    • {bufnr}: (Number, Optional) if provided it must be the id of an open
    buffer.

    • {opts}: (Table, Optional). Supports the following properties:

        • formatting_options: Settings send to the language server. These
        are the same settings as the `formatting_options` argument in
        |vim.lsp.buf.format()|.

        • timeout_ms: (Number, Optional) Defaults to 10000. Time in
        milliseconds to ignore the current format request.

    Do not use this in the global `on_attach`, call this function
    with the specific language server you want to format with.

    Here is an example.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').tsserver.setup({
      on_attach = function(client, bufnr)
        lsp_zero.async_autoformat(client, bufnr)
      end
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp_zero.setup_servers({'rust_analyzer'})
<
                                                   *lsp-zero.format_mapping()*
format_mapping({key}, {opts}): ~
    Configure {key} to format the current buffer.

    The idea here is that you associate a language server with a list of
    filetypes, so {key} can format the buffer using only one LSP server.

    {opts} supports the following properties:

        • servers: (Table) Key/value pair list. On the left hand side you must
        specify the name of a language server. On the right hand side you must
        provide a list of filetypes, this can be any pattern supported
        by the |FileType| autocommand.

        • mode: (Table). The list of modes where the keybinding will be active.
        By default is set to `{'n', 'x'}`, which means normal mode and visual
        mode.

        • format_opts: (Table, optional). Configuration that will passed to
        the formatting function. It supports the following properties:

            • async: (Boolean, optional). If true it will send an
              asynchronous format request to the LSP server.

            • timeout_ms: (Number, optional). Time in milliseconds to block
            for formatting requests. Defaults to `10000`.

            • formatting_options: (Table, optional). Can be used to set
            `FormattingOptions`, these options are sent to the language
            server. See https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#formattingOptions

    Tabs and indents can change after the LSP formats the code in the file. Read
    the documentation of the LSP servers you are using, figure out how to
    configure it to your prefered style.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    lsp_zero.format_mapping('gq', {
      servers = {
        ['rust_analyzer'] = {'rust'},
        ['tsserver'] = {'javascript', 'typescript'},
      }
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp_zero.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                   *lsp-zero.set_sign_icons()*

set_sign_icons({opts}): ~
    Defines the sign icons that appear in the gutter.

    {opts} table supports these properties:

        • error: (String, Optional) Text for the error signs.

        • warn: (String, Optional) Text for the warning signs.

        • hint: (String, Optional) Text for the hint signs.

        • info: (String, Optional) Text for the information signs.

    Here is an example with basic icons (doesn't require a nerd fonts).
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.set_sign_icons({
      error = '✘',
      warn = '▲',
      hint = '⚑',
      info = '»'
    })
<
                                                      *lsp-zero.new_client()*

new_client({opts}): ~
    lsp-zero will execute a user provided function to detect the root
    directory of the project when Neovim assigns the file type for a
    buffer. If the root directory is detected the LSP server will be
    attached to the file.

    This function does not depend on `lspconfig`, it's a thin wrapper
    around a Neovim function called |vim.lsp.start()|.

    {opts} supports every property |vim.lsp.start()| supports with
    a few changes:

        • filestypes: (Table) Can be list filetype names. This can be
        any pattern the `FileType` autocommand accepts.

        • root_dir: Can be a function, it'll be executed after Neovim
        assigns the file type for a buffer. If it returns a string
        that will be considered the root directory for the project.

    Other important properties are:

        • cmd: (Table) A lua table with the arguments necessary to start
        the language server.

        • name: (String) The name Neovim will assign to the client object.

        • on_attach: (Function) A function that will be executed after
        the language server gets attached to a buffer.

    Here is an example that starts the typescript language server on
    javascript and typescript, but only in a project that package.json
    in the current directory or any of its parent folders.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function()
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    lsp_zero.new_client({
      name = 'tsserver',
      cmd = {'typescript-language-server', '--stdio'},
      filetypes = {'javascript', 'typescript'},
      root_dir = function()
        return lsp_zero.dir.find_first({'package.json'})
      end
    })
<
                                                   *lsp-zero.dir.find_first()*

dir.find_first({list}): ~
    Checks the parent directories and returns the path to the first folder
    that has a file in {list}. Useful to detect the root directory.

    {list} supports the following properties:

      • path: (String, Optional) The path from where it should start looking for
      the files in {list}.

      • buffer: (Boolean, Optional) When enabled it will use the path of the
      current buffer.

    Note: search will stop once it gets to your "HOME" folder.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').lua_ls.setup({
      root_dir = function()
        --- project root will be the first directory that has
        --- either .luarc.json or .stylua.toml
        return lsp_zero.dir.find_first({'.luarc.json', '.stylua.toml'})
      end
    })
<
                                                     *lsp-zero.dir.find_all()*

dir.find_all({list}): ~
    Checks the parent directories and returns the path to the first folder
    that has all the files in {list}. Useful to detect the root directory.

    {list} supports the following properties:

      • path: (String, Optional) The path from where it should start looking
      for the files in {list}.

      • buffer: (Boolean, Optional) When enabled use the path of the current
      buffer.

    Note: search will stop once it gets to your "HOME" folder.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.on_attach(function(client, bufnr)
      lsp_zero.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').lua_ls.setup({
      root_dir = function()
        --- project root will be the first directory that has
        --- either .luarc.json or .stylua.toml
        return lsp_zero.dir.find_first({'.luarc.json', '.stylua.toml'})
      end
    })
<

                                                 *lsp-zero.extend_lspconfig()*

extend_lspconfig(): ~
    Takes care of the integration between lspconfig and nvim-cmp.

    It extends the `capabilities` option in lspconfig's defaults, using the
    plugin `cmp_nvim_lsp`. And it creates a "hook" so users can provide their
    own default config using |lsp-zero.set_server_config()|.

                                                       *lsp-zero.cmp_action()*

cmp_action(): ~
    Returns methods meant to be used as mappings for |nvim-cmp|.

    These are the supported methods:

        • tab_complete: ~
            Enables completion when the cursor is inside a word. If the
            completion menu is visible it will navigate to the next item in
            the list. If the line is empty it uses the fallback.

        • select_prev_or_fallback: ~
            If the completion menu is visible navigate to the
            previous item in the list. Else, uses the fallback.

        • toggle_completion: ~
            If the completion menu is visible it cancels the process. Else, it
            triggers the completion menu. You can use the property `modes` in
            the first argument to specify where this mapping should active
            (the default is `{modes = {'i'}}`).

        • luasnip_jump_forward: ~
            Go to the next placeholder in the snippet.

        • luasnip_jump_backward: ~
            Go to the previous placeholder in the snippet.

        • luasnip_next: ~
            If completion menu is visible it will navigate to the item in the
            list. If the cursor can jump to a snippet placeholder, it moves to
            it. Else, it uses the fallback.

        • luasnip_next_or_expand: ~
            If completion menu is visible it will navigate to the item in the
            list. If cursor is on top of the trigger of a snippet it'll expand
            it. If the cursor can jump to a snippet placeholder, it moves to
            it. Else, it uses the fallback.

        • luasnip_supertab: ~
            If the completion menu is visible it will navigate to the
            next item in the list. If cursor is on top of the trigger
            of a snippet it'll expand it. If the cursor can jump to a
            snippet placeholder, it moves to it. If the cursor is in
            the middle of a word that doesn't trigger a snippet it
            displays the completion menu. Else, it uses the fallback.

        • luasnip_shift_supertab: ~
            If the completion menu is visible it'll navigate to previous item
            in the list. If the cursor can navigate to a previous snippet
            placeholder, it moves to it. Else, it uses the fallback.

    Quick note: "the fallback" is the default behavior of the key
    you assign to a method.

                                                       *lsp-zero.cmp_format()*

cmp_format(): ~
    When used the completion items will show a label that identifies the
    source they come from.
>lua
    local cmp = require('cmp')
    local cmp_format = require('lsp-zero').cmp_format()

    cmp.setup({
      formatting = cmp_format
    })
<
                                                       *lsp-zero.extend_cmp()*

extend_cmp({opts}): ~
    Creates a minimal working config for nvim-cmp.

    {opts} supports the following properties:

        • set_lsp_source: (Boolean, Optional) Defaults to `true`. When enabled
        it adds `cmp-nvim-lsp` as a source.

        • set_mappings: (Boolean, Optional) Defaults to `true`. When
        enabled it will create keybindings that emulate Neovim's default
        completions bindings.

        • use_luasnip: (Boolean, Optional) Defaults to `true`. When enabled it
        will setup luasnip to expand snippets. This option does not include a
        collection of snippets.

    After you use this function you can customize nvim-cmp using the module
    `cmp`. Here is an example that adds some keybindings.
>lua
    require('lsp-zero').extend_cmp()

    local cmp = require('cmp')
    local cmp_action = require('lsp-zero').cmp_action()

    cmp.setup({
      mapping = cmp.mapping.preset.insert({
        ['<C-Space>'] = cmp.mapping.complete(),
        ['<C-f>'] = cmp_action.luasnip_jump_forward(),
        ['<C-b>'] = cmp_action.luasnip_jump_backward(),
      })
    })
<
                                                   *lsp-zero.omnifunc.setup()*

.omnifunc.setup({opts}): ~
    Configure the behavior of Neovim's completion mechanism. If for some
    reason you refuse to install nvim-cmp you can use this function to
    make the built-in completions more user friendly.

    {opts} supports the following properties:

        • autocomplete: (String, Optional) Defaults to `false`. When enabled
        it triggers the completion menu if the character under the cursor
        matches `opts.keyword_pattern`. Completions will be disabled when you
        are recording a macro. Do note, the implementation here is extremely
        simple, there isn't any kind of optimizations in place. Is literally
        like pressing `<Ctrl-x><Ctrl-o>` after you insert a character in a
        word.

        • tabcomplete: (Boolean, Optional) Defaults to `false`. When enabled
        `<Tab>` will trigger the completion menu if the cursor is in the
        middle of a word. When the completion menu is visible it will navigate
        to the next item in the menu. If there is a blank character under the
        cursor it inserts a `Tab` character. `<Shift-Tab>` will navigate to
        the previous item in the menu, and if the menu is not visible it'll
        insert a `Tab` character.

        • trigger: (String, Optional) It must be a valid keyboard shortcut.
        This will be used as a keybinding to trigger the completion menu
        manually. Actually, it will be able to toggle the completion menu.
        You'll be able to show and hide the menu with the same keybinding.

        • use_fallback: (Boolean, Optional) Defaults to `false`. When enabled
        lsp-zero will try to complete using the words in the current buffer.
        And when an LSP server is attached to the buffer, it will replace the
        fallback completion with the LSP completions.

        • keyword_pattern: (String, Optional) Defaults to `"[[:keyword:]]"`.
        Regex pattern used by the autocomplete implementation.

        • update_on_delete: (Boolean, Optional) Defaults to `false`. Turns out
        Neovim will hide the completion menu when you delete a character, so
        when you enable this option lsp-zero will trigger the menu again after
        you press `<backspace>`. This will only happen with LSP completions,
        the fallback completion updates automatically (again, this is Neovim's
        default behavior). This option is disabled by default because it
        requires lsp-zero to bind the backspace key, which may cause conflicts
        with other plugins.

        • select_behavior: (String, Optional) Defaults to `"select"`.
        Configures what happens when you select an item in the completion
        menu. When the value is `"insert"` Neovim will insert the text of the
        item in the buffer. When the value is `"select"` nothing happens,
        Neovim will only highlight the item in the menu, the text in the
        buffer will not change.

        • preselect: (Boolean, Optional) Defaults to `true`. When enabled the
        first item in the completion menu will be selected automatically.

        • verbose: (Boolean, Optional) Defaults to `false`. When enabled
        Neovim will show the state of the completion in message area.

        • mapping: (Table, Optional) Defaults to an empty table. With this you
        can configure the keybinding for common actions.

            • confirm: Accept the selected completion item.

            • abort: Cancel current completion.

            • next_item: Navigate to next item in the completion menu.

            • prev_item: Navigate to previous item in the completion menu.

    You can configure a basic "tab completion" behavior using these settings.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.omnifunc.setup({
      tabcomplete = true,
      use_fallback = true,
      update_on_delete = true,
    })
<
    And here is an example for autocomplete.
>lua
    local lsp_zero = require('lsp-zero')

    lsp_zero.omnifunc.setup({
      autocomplete = true,
      use_fallback = true,
      update_on_delete = true,
      trigger = '<C-Space>',
    })
<
==============================================================================
Guides                                                       *lsp-zero-guides*

                                   *lsp-zero-guide:integrate-with-mason-nvim*

Integrate with mason.nvim

We can use |mason.nvim| and |mason-lspconfig.nvim| to help us manage the
installation of language servers. And then we can use lsp-zero to help with
the automatic configuration.

Here is a basic example.
>lua
  local lsp_zero = require('lsp-zero')

  lsp_zero.on_attach(function(client, bufnr)
    -- see :help lsp-zero-keybindings
    -- to learn the available actions
    lsp_zero.default_keymaps({buffer = bufnr})
  end)

  require('mason').setup({})
  require('mason-lspconfig').setup({
    -- Replace the language servers listed here 
    -- with the ones you want to install
    ensure_installed = {'tsserver', 'rust_analyzer'},
    handlers = {
      lsp_zero.default_setup,
    },
  })
<

This config will tell `mason-lspconfig` to install tsserver and rust_analyzer
automatically if they are missing. And lsp-zero will handle the configuration
of those servers.

Note that after you install a language server you will need to restart Neovim
so the language can be configured properly.

If we need to add a custom configuration for a server, you'll need to add a
property to `handlers`. This new property must have the same name as the
language server you want to configure, and you need to assign a function to
it.

Lets use `tsserver` as an example.
>lua
  require('mason-lspconfig').setup({
    ensure_installed = {'tsserver', 'rust_analyzer'},
    handlers = {
      lsp_zero.default_setup,
      tsserver = function()
        require('lspconfig').tsserver.setup({
          settings = {
            completions = {
              completeFunctionCalls = true
            }
          }
        })
      end,
    },
  })
<
Here we use the module `lspconfig` to setup the language server and we add our
custom config in the first argument of `.tsserver.setup()`.

On the other hand if we want to ignore a language server we can use the
function |lsp-zero.noop()|.
>lua
  require('mason-lspconfig').setup({
    ensure_installed = {'tsserver', 'rust_analyzer'},
    handlers = {
      lsp_zero.default_setup,
      tsserver = lsp_zero.noop,
    },
  })
<
This will cause `mason-lspconfig` to exclude `tsserver` from the automatic
setup.

                                          *lsp-zero-guide:lua-lsp-for-neovim*

Configure lua language server for Neovim

There are two ways you can do this:

• Project specific config

We can create a file called .luarc.json file in Neovim's config folder and the
following config.
>
  {
    "runtime.version": "LuaJIT",
    "runtime.path": [
      "lua/?.lua",
      "lua/?/init.lua"
    ],
    "diagnostics.globals": ["vim"],
    "workspace.checkThirdParty": false,
    "workspace.library": [
      "$VIMRUNTIME",
      "./lua"
    ]
  }
<
• Fixed config

If your Neovim config is the only lua project you have in your system, use the
function |lsp-zero.nvim_lua_ls()| to get the config and then setup `lua_ls`
with lspconfig.
>lua
  local lsp_zero = require('lsp-zero')

  lsp_zero.on_attach(function(client, bufnr)
    -- see :help lsp-zero-keybindings
    -- to learn the available actions
    lsp_zero.default_keymaps({buffer = bufnr})
  end)

  local lua_opts = lsp_zero.nvim_lua_ls()
  require('lspconfig').lua_ls.setup(lua_opts)
<
If you used |mason-lspconfig.nvim| to setup your language servers, add
`lua_ls` to your handlers config.
>lua
  require('mason-lspconfig').setup({
    handlers = {
      lsp_zero.default_setup,
      lua_ls = function()
        local lua_opts = lsp_zero.nvim_lua_ls()
        require('lspconfig').lua_ls.setup(lua_opts)
      end,
    },
  })
<
                                          *lsp-zero-guide:customize-nvim-cmp*

Customize nvim-cmp

You can call the setup function of the `cmp` module. Here is a quick example.
>lua
  local cmp = require('cmp')
  local cmp_action = require('lsp-zero').cmp_action()

  cmp.setup({
    window = {
      completion = cmp.config.window.bordered(),
      documentation = cmp.config.window.bordered(),
    },
    mapping = cmp.mapping.preset.insert({
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-f>'] = cmp_action.luasnip_jump_forward(),
      ['<C-b>'] = cmp_action.luasnip_jump_backward(),
      ['<C-u>'] = cmp.mapping.scroll_docs(-4),
      ['<C-d>'] = cmp.mapping.scroll_docs(4),
    })
  })
<
When configuring the `sources` option make sure to add the source for the LSP
completions.
>lua
  local cmp = require('cmp')

  cmp.setup({
    sources = {
      {name = 'nvim_lsp'},
    }
  })
<

Always include `{name = 'nvim_lsp'}` in your sources.

                                         *lsp-zero-guide:fix-extend-lspconfig*

Fix lspconfig error

What you need to do is call the function `.extend_lspconfig()` before you
setup any language server. I suggest you call it right after you require
lsp-zero.
>lua
  local lsp_zero = require('lsp-zero')
  lsp_zero.extend_lspconfig()

  lsp_zero.on_attach(function(client, bufnr)
    lsp_zero.default_keymaps({buffer = bufnr})
  end)
<
If you are using `mason-lspconfig`, call the function `.extend_lspconfig()`
before you setup mason-lspconfig.
<
If you actually want to ignore error and supress the message, you can set the
global variable `lsp_zero_extend_lspconfig` to `0`. And do it before you
require the module `lsp-zero`.

This is how you do it using lua.
>lua
  vim.g.lsp_zero_extend_lspconfig = 0
<
Or if you prefer vimscript.
>vim
  let g:lsp_zero_extend_lspconfig = 0
<
==============================================================================
Version                                                     *lsp-zero-version*

Current version: `v3.x`

The code on this version requires Neovim v0.8 or greater.

If you need support for Neovim v0.7 use the `compat-07` branch. That will have
the same api as v3.x.

If you need support for Neovim v0.6.2 or lower use the `v1.x` branch of
lsp-zero.

==============================================================================
Support                                                    *lsp-zero-donation*

If you find this tool useful and want to support my efforts, consider
leaving a tip in https://www.buymeacoffee.com/vonheikemen

vim:tw=78:ft=help:norl:
